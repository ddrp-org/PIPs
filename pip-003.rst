PIP-3: Blobs
============

.. contents:: Table of Contents
   :local:

Overview
########

A blob is a fixed-size file that contains the data associated with a single Handshake name. They are conceptually similar to storage volumes in that they support random-access reads and writes within a size bound.

Nomenclature
############

blob size
  The maximum size of a blob. Currently, this is set to 16 mebibytes (16,777,216 bytes).

sector size
  The maximum size of a sector. Currently, this is set to 65,536 bytes.

sector ID
  The index of a sector within a blob. For example, given the blob and sector sizes above, the sector ID representing offsets 65,536-131,072 would be ``1``.

chunk size
  The maximum size of a chunk. Currently, this is set to 256 bytes.


Blob Layout
###########

A blob is a file that is exactly ``blob size`` in length. Data may be written to or read from any offset within the blob. Offsets that have not been explicitly written to are assumed to contain null bytes. Implementations MAY store blobs however they see fit as long as these constraints are respected.

Blobs are further partitioned into ``blob size/sector size`` sectors. Sectors are used by the synchronization protocol described by `PIP-4`_ to determine which pieces of the blob have changed, and authenticate those changes. Sectors have IDs, which correspond to their indices within each blob.

Sectors are also partitioned into ``sector size/chunk size`` chunks. Chunks are used by synchronization protocol described by `PIP-4`_ to optimize synchronization time for frequent sub-sector changes. Chunks have IDs, which correspond to their indices within each sectors.

Diagrammatically, blobs look like this:

.. code-block::

  +-----------------------------------+
  |  Chunk 0  |  Chunk 1  |  Chunk 2  | 
  | (0 - 255) | (256-511) | (512-767) |
  |                                   |
  |             Sector 0              |
  |         (Offsets 0-65535)         |
  |                                   |
  |                 |    Chunk 255    |
  |                 | (65,280-65,535) |
  +-----------------------------------+
  |             Sector 1              |
  |      (Offsets 65536-131072)       |
  +-----------------------------------+
  |                                   |
  |                                   |
  |                ...                |
  |                                   |
  |                                   |
  |                                   |
  +-----------------------------------+
  |            Sector 255             |
  |    (Offsets 16711680-16777216)    |
  +-----------------------------------+


Blob Merkleization
##################

DDRP uses a binary Merkle tree with a custom leaf-hashing function to generate the Merkle root. Blob owners then sign over the blob's Merkle root to authenticate the data contained therein. 

Custom Leaf Generation
**********************
 
We can generate the tree's leaves using each sector as input.

1. Separate sector into a list of 256-byte chunks.
2. Turn each chunks into a ``BLAKE2B-256`` hash (``chunk_hash``).
3. Starting from the first chunks, for chunks ``[0...n]``,
   a) If ``leaf_value`` is null, set ``leaf_value`` to a ``BLAKE2B-256`` hash of current ``chuck_hash``.
   b) if ``leaf_value`` is not null, set ``leaf_value`` to a ``BLAKE2B-256`` hash of current ``chuck_hash`` and ``value``.
   c) Repeat until chunk ``n``.

See the sub-sector request described in `PIP-4`_ for more details on how this is used to optimize sub-sector synchronization.

Tree Visualization
******************

To determine which sectors have changed, the synchronization process described in `PIP-4`_ uses something called a "Merkle base" to compare the contents of two blobs. Consider the following small Merkle tree, the merkle base is ``[H(A), H(B), H(C), H(D)]``


.. code-block::

                   +-----------------------------+
                   |                             |
                   |                             |                  
                   +-----------------------------+
                                  |
                 +----------------+----------------+
                 |                                 |
         +-------v------+                  +-------v------+
         |              |                  |              |
         |              |                  |              |         
         +--------------+                  +--------------+
                 |                                 |
        +--------+-------+                +--------+-------+
        |                |                |                |
  +-----v----+     +-----v----+     +-----v----+     +-----v----+
  |   H(A)   |     |   H(B)   |     |   H(C)   |     |   H(D)   |
  |          |     |          |     |          |     |          |   
  +-----^----+     +-----^----+     +-----^----+     +-----^----+
        |                |                |                |
  +-----+----+     +-----+----+     +-----+----+     +-----+----+
  |  Sect A  |     |  Sect B  |     |  Sect C  |     |  Sect D  |
  | (65536b) |     | (65536b) |     | (65536b) |     | (65536b) |
  +----------+     +----------+     +----------+     +----------+



Blob Ownership
##############

"Ownership" of a blob is determined by a ``TXT`` record on the Handshake blockchain. The ``TXT`` record is structured as ``DDRPKEY:<pub>``, where ``<pub>`` is a compressed ``secp256k1`` encoded as hexadecimal. The individual who possesses the private key is considered the blob's "owner," and is able to authorize changes to the blob by signing over its name, Merkle root, timestamp.

When parsing the ``TXT`` record:

1. Nodes MUST tolerate mal-formed ``DDRPKEY`` ``TXT`` records by ignoring them.
2. If multiple ``DDRPKEY`` ``TXT`` records are present for a given TLD, nodes MUST ignore all other records except the first.
   
Subdomain Partition Ownership
#############################

Blob owners can delgate ownership of a partition (see `PIP-8`_) within a blob 

Blob Signatures
###############

The owner of a blob signs over its contents by generating the ``schnorr`` signature of the hash ``BLAKE2B-256("DDRPBLOB", name, update timestamp, merkle root, reserved)``, encoded as follows:

#. ``DDRPBLOB``: Encoded as an ASCII ``[8]byte``.
#. ``name``: A ``string``.
#. ``update timestamp``: A ``uint64`` of the timestamp, encoded as per `PIP-1`_.
#. ``merkle root``: A ``[32]byte``, encoded as per `PIP-1`_.
#. ``reserved``: A ``[32]byte`` buffer from the ``reserved`` field in `PIP-4`_, encoded as per `PIP-1`_. These bytes may be used as part of future protocol upgrades.

Authors
#######

- `Matthew Slipper`_

.. _PIP-8: ./pip-008.html
.. _PIP-4: ./pip-004.html
.. _PIP-1: ./pip-001.html
.. _Matthew Slipper: https://www.matthewslipper.com
